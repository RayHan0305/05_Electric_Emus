======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Electric Emus

Processing all weeks found in repository

Your current Git repo size is about 1.47 MiB on disk

Found directories: .git, Feedback, week3
Found files: .gitignore, README.md, list.txt

Processing all weeks: week3

Found 3 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: align_seqs_better.py

Contents:

**********
"""
Usage:
    python3 align_seqs_better.py ../data/<filename1> ../data/<filename2>

Description:
    This script aligns two DNA sequences from FASTA files.
    It compares all possible alignments and finds all equally-best alignments
    (not just the first one). 
    The results are saved to the ../results/ directory, using the pickle module.
    
Author: 'Ruixuan Han, Lawson-Hale Tasha L'
Version: 0.0.1
License: License for this code/program

__appname__ = 'align_seqs_better'
__author__ = 'Ruixuan Han'
__version__ = '0.0.1'
"""

import sys
import os
import pickle

# Read a FASTA file and return the sequence as a string
def read_fasta(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        seq = "".join([line.strip() for line in lines if not line.startswith(">")])
    return seq

# Calculate alignment score between s1 and s2 starting at startpoint.
def calculate_score(s1, s2, l1, l2, startpoint):
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]:
                score += 1
    return score

def main(argv):
    if len(argv) != 3:
        sys.exit(0)
        
    seq1_file = argv[1]
    seq2_file = argv[2]

    # Read FASTA sequences
    seq1 = read_fasta(seq1_file)
    seq2 = read_fasta(seq2_file)

    l1, l2 = len(seq1), len(seq2)
    if l1 >= l2:
        s1, s2 = seq1, seq2
    else:
        s1, s2 = seq2, seq1
        l1, l2 = l2, l1

    # Alignment comparison
    my_best_align = []
    my_best_score = -1

    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = ["." * i + s2]   
            my_best_score = z
        elif z == my_best_score:
            my_best_align.append("." * i + s2)
            
    print("Best score:", my_best_score)
    print("Number of equally-best alignments:", len(my_best_align))

    # Save results
    results_dir = "../results"
    os.makedirs(results_dir, exist_ok=True)
    output_file = os.path.join(results_dir, "best_alignments.pickle")

    with open(output_file, "wb") as f:
        pickle.dump({
            "best_score": my_best_score,
            "alignments": my_best_align,
            "seq1": s1,
            "seq2": s2
        }, f)

    print(f"Results saved to: {output_file}")
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))

**********

Output (first 500 chars):

**********

**********
No errors.
======================================================================
Script: align_seqs_fasta.py

Contents:

**********
#!/usr/bin/env python3

"""
align_seqs_fasta.py
This script will align any two DNA sequences from FASTA files in data/.

Usage: 
    This script will take any two fasta sequences (in seperate file in data folder) to be aligned as input.

    Method 1(default):
    No parameters (It will try to use ../data/seq1.fasta and seq2.fasta by default, and if they’re not there, it will automatically pick the first two FASTA files it finds in the ../data/ directory.)

    python3 align_seqs_faster.py

    Method 2:
    Explicitly specify two fasta files as input.
    python3 align_seqs_fasta.py seq1.fasta seq2.fasta
    (for example: python3 align_seqs_fasta.py ../data/407228326.fasta ../data/407228412.fasta)
    There are three fasta files in data/ now which are 407228326.fasta; 407228412.fasta; E.coli.fasta
"""

__appname__ = 'align_seqs_faster'
__author__ = 'Ximan Ding'
__version__ = '0.0.1'
__license__ = "License for this code/program"

from pathlib import Path
import sys
from typing import Tuple, List
import argparse

def read_fasta(p: Path) -> str:
    """Read a (single-sequence) FASTA and return uppercase sequence."""
    return "".join(
        line.strip() for line in p.read_text().splitlines()
        if line and not line.startswith(">")
    ).upper()

def score_at_start(longer: str, shorter: str, start: int) -> int:
    L1, L2 = len(longer), len(shorter)
    score = 0
    for i in range(L2):
        j = start + i
        if j >= L1: break
        if longer[j] == shorter[i]:
            score += 1
    return score

def match_line(longer: str, shorter: str, start: int) -> str:
    L1, L2 = len(longer), len(shorter)
    marks = []
    for i in range(L2):
        j = start + i
        if j >= L1: break
        marks.append("*" if longer[j] == shorter[i] else "-")
    return "." * start + "".join(marks)

def best_alignment(a: str, b: str):
    """Return (longer, padded_shorter, match_visual, best_score, best_start)."""
    longer, shorter = (a, b) if len(a) >= len(b) else (b, a)
    best_score, best_start = -1, 0
    for start in range(len(longer)):
        sc = score_at_start(longer, shorter, start)
        if sc > best_score:
            best_score, best_start = sc, start
    padded_shorter = "." * best_start + shorter
    return longer, padded_shorter, match_line(longer, shorter, best_start), best_score, best_start

def auto_two_fastas(data_dir: Path):
    files = sorted(list(data_dir.glob("*.fa")) + list(data_dir.glob("*.fasta")) + list(data_dir.glob("*.fna")))
    if len(files) < 2:
        raise SystemExit(f"[ERROR] Need at least 2 FASTA in {data_dir}")
    return files[0], files[1]

def save_result(out_path: Path, f1: Path, f2: Path, longer: str, padded: str, vis: str, score: int, start: int):
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(
        "# align_seqs_fasta.py result\n"
        f"Input 1: {f1}\nInput 2: {f2}\n\n"
        f"Best score: {score}\nStart on longer (0-based): {start}\n\n"
        f"{longer}\n{padded}\n{vis}\n"
    )

def main(argv):
    proj = Path(__file__).resolve().parent.parent
    data_dir = proj / "data"
    out_file = proj / "results" / "align_seqs_fasta_result.txt"

    if len(argv) == 3:
        f1, f2 = Path(argv[1]), Path(argv[2])
    elif len(argv) == 1:
        f1, f2 = auto_two_fastas(data_dir)
        print(f"[INFO] Using defaults from {data_dir}: {f1.name}, {f2.name}")
    else:
        print("Usage: python3 align_seqs_fasta.py <seq1.fasta> <seq2.fasta>")
        return 1

    s1, s2 = read_fasta(f1), read_fasta(f2)
    longer, padded, vis, score, start = best_alignment(s1, s2)

    print("\n=== Best alignment ===")
    print(f"Score: {score}    Start(on longer): {start}\n")
    print(longer)
    print(padded)
    print(vis)

    save_result(out_file, f1, f2, longer, padded, vis, score, start)
    print(f"\n[OK] Result saved to: {out_file}")
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))
**********

Output (first 500 chars):

**********
[INFO] Using defaults from /home/mhasoba/Documents/Teaching/IC_CMEE/2025-26/Coursework/StudentRepos/ElectricEmus_/week3/data: 407228326.fasta, 407228412.fasta

=== Best alignment ===
Score: 545    Start(on longer): 76

AGAATGGCGCAGCCACTTTGGAAGACAGTTTGGCAGTTTCTTACAAAGCTAAACATACTCTTACTATATGATCTAGCAATTGTGCTTCTAGGTATTTACTTACCCAAGGAGTTGAAAACTTATGCCCACACAAAAACCTGCACATGATGTTGATAGCATCTTTACCCATAATTGCCAAAAAGTTGAAGGAACCAAAGTGTCCTTCAAAAGGCGAATGGGTAGAACAACTGTGGTACATCCAGACAATGGAATATCATTCAGAGACAAAAAGCAATGAGCTG
**********
No errors.
======================================================================
Script: Groupwork_oaks_debugme.py

Contents:

**********
#!/usr/bin/env python3

"""
Description: This script filters species names in a CSV file, identifying those 
belonging to the Quercus genus (oak trees), and writes them to a new CSV file. 
It reads from an input file, processes the data, and saves the results to an output file.
1. Skip the header row so that "Genus, species" isn't traeated as data.
2. INclude the header in the output file.
Additionally, it includes a function with built-in tests using doctest.

Author: 'Zhiquan Kang, Lawson-Hale Tasha L, Lisa Paruit'
Version: 0.0.1
License: License for this code/program
"""

__appname__ = 'Groupwork_oaks_debugme'
__author__ = 'Zhiquan Kang'
__version__ = '0.0.1'


import csv
import sys
import os

# Ensure the output directory exists, creating it if necessary
results_dir = '../results'
try:
    os.makedirs(results_dir, exist_ok=True)
except OSError as e:
    print(f"Error creating directory '{results_dir}': {e}")
    # Exit with an error code if directory creation fails
    exit(1) 


def is_an_oak(name):
    """ 
    Returns True if the name starts with 'quercus or Quercus'  

    Examples:
    >>> is_an_oak('Fagus sylvatica') 
    False

    >>> is_an_oak('Quercus sylvatica')
    True

    >>> is_an_oak('Quercuss sylvatica') 
    False
    """
    return name.split()[0] in ('quercus', 'Quercus') 

# print(str(is_an_oak('Quercuss sylvatica')) + " test complete" + '\n')
# gives false

    
def main(argv): 

    # Open the input and output files
    with open('../data/TestOaksData.csv', 'r') as f, open('../results/JustOaksData.csv', 'w', newline='') as g:
        taxa = csv.reader(f)
        csvwrite = csv.writer(g)
        oaks = set()
        
        # Write column headers for the output CSV
        csvwrite.writerow(["Genus", "Species"])
        next(taxa)  # Skip the 'Genus' and 'Species' headers in the input file

        # Iterate through rows in the input CSV
        for row in taxa:
            print(row)
            print("The genus is:") 
            print(row[0] + '\n')
            if is_an_oak(row[0]):
                print('FOUND AN OAK!\n')
                csvwrite.writerow([row[0], row[1]])

    print("Oak names have been written to", '../results/JustOaksData.csv')
    
    return 0

    
if (__name__ == "__main__"):
    status = main(sys.argv)
**********

Output (first 500 chars):

**********
['Quercus', ' robur']
The genus is:
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is:
Fraxinus

['Pinus', ' sylvestris']
The genus is:
Pinus

['Quercus', ' cerris']
The genus is:
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is:
Quercus

FOUND AN OAK!

Oak names have been written to ../results/JustOaksData.csv

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 3
Scripts successful: 3
Scripts with errors: 0
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

